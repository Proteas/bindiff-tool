// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: binexport2.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30004
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30004 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class BinExport2_BasicBlock;
@class BinExport2_BasicBlock_IndexRange;
@class BinExport2_CallGraph;
@class BinExport2_CallGraph_Edge;
@class BinExport2_CallGraph_Vertex;
@class BinExport2_Comment;
@class BinExport2_DataReference;
@class BinExport2_Expression;
@class BinExport2_FlowGraph;
@class BinExport2_FlowGraph_Edge;
@class BinExport2_Instruction;
@class BinExport2_Library;
@class BinExport2_Meta;
@class BinExport2_Mnemonic;
@class BinExport2_Module;
@class BinExport2_Operand;
@class BinExport2_Reference;
@class BinExport2_Section;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum BinExport2_CallGraph_Vertex_Type

typedef GPB_ENUM(BinExport2_CallGraph_Vertex_Type) {
  /** Regular function with full disassembly. */
  BinExport2_CallGraph_Vertex_Type_Normal = 0,

  /** This function is a well known library function. */
  BinExport2_CallGraph_Vertex_Type_Library = 1,

  /** Imported from a dynamic link library (e.g. dll). */
  BinExport2_CallGraph_Vertex_Type_Imported = 2,

  /** A thunk function, forwarding its work via an unconditional jump. */
  BinExport2_CallGraph_Vertex_Type_Thunk = 3,

  /**
   * An invalid function (a function that contained invalid code or was
   * considered invalid by some heuristics).
   **/
  BinExport2_CallGraph_Vertex_Type_Invalid = 4,
};

GPBEnumDescriptor *BinExport2_CallGraph_Vertex_Type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL BinExport2_CallGraph_Vertex_Type_IsValidValue(int32_t value);

#pragma mark - Enum BinExport2_Expression_Type

typedef GPB_ENUM(BinExport2_Expression_Type) {
  BinExport2_Expression_Type_Symbol = 1,
  BinExport2_Expression_Type_ImmediateInt = 2,
  BinExport2_Expression_Type_ImmediateFloat = 3,
  BinExport2_Expression_Type_Operator = 4,
  BinExport2_Expression_Type_Register = 5,
  BinExport2_Expression_Type_SizePrefix = 6,
  BinExport2_Expression_Type_Dereference = 7,
};

GPBEnumDescriptor *BinExport2_Expression_Type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL BinExport2_Expression_Type_IsValidValue(int32_t value);

#pragma mark - Enum BinExport2_FlowGraph_Edge_Type

typedef GPB_ENUM(BinExport2_FlowGraph_Edge_Type) {
  BinExport2_FlowGraph_Edge_Type_ConditionTrue = 1,
  BinExport2_FlowGraph_Edge_Type_ConditionFalse = 2,
  BinExport2_FlowGraph_Edge_Type_Unconditional = 3,
  BinExport2_FlowGraph_Edge_Type_Switch = 4,
};

GPBEnumDescriptor *BinExport2_FlowGraph_Edge_Type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL BinExport2_FlowGraph_Edge_Type_IsValidValue(int32_t value);

#pragma mark - Enum BinExport2_Comment_Type

typedef GPB_ENUM(BinExport2_Comment_Type) {
  /**
   * A regular instruction comment. Typically displayed next to the
   * instruction disassembly.
   **/
  BinExport2_Comment_Type_Default = 0,

  /**
   * A comment line that is typically displayed before (above) the
   * instruction it refers to.
   **/
  BinExport2_Comment_Type_Anterior = 1,

  /** Like ANTERIOR, but a typically displayed after (below). */
  BinExport2_Comment_Type_Posterior = 2,

  /**
   * Similar to an ANTERIOR comment, but applies to the beginning of an
   * identified function. Programs displaying the proto may choose to render
   * these differently (e.g. above an inferred function signature).
   **/
  BinExport2_Comment_Type_Function = 3,

  /** Named constants, bitfields and similar. */
  BinExport2_Comment_Type_Enum = 4,

  /** Named locations, usually the target of a jump. */
  BinExport2_Comment_Type_Location = 5,

  /** Data cross references. */
  BinExport2_Comment_Type_GlobalReference = 6,

  /** Local/stack variables. */
  BinExport2_Comment_Type_LocalReference = 7,
};

GPBEnumDescriptor *BinExport2_Comment_Type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL BinExport2_Comment_Type_IsValidValue(int32_t value);

#pragma mark - Binexport2Root

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface Binexport2Root : GPBRootObject
@end

#pragma mark - BinExport2

typedef GPB_ENUM(BinExport2_FieldNumber) {
  BinExport2_FieldNumber_MetaInformation = 1,
  BinExport2_FieldNumber_ExpressionArray = 2,
  BinExport2_FieldNumber_OperandArray = 3,
  BinExport2_FieldNumber_MnemonicArray = 4,
  BinExport2_FieldNumber_InstructionArray = 5,
  BinExport2_FieldNumber_BasicBlockArray = 6,
  BinExport2_FieldNumber_FlowGraphArray = 7,
  BinExport2_FieldNumber_CallGraph = 8,
  BinExport2_FieldNumber_StringTableArray = 9,
  BinExport2_FieldNumber_AddressCommentArray = 10,
  BinExport2_FieldNumber_StringReferenceArray = 11,
  BinExport2_FieldNumber_ExpressionSubstitutionArray = 12,
  BinExport2_FieldNumber_SectionArray = 13,
  BinExport2_FieldNumber_LibraryArray = 14,
  BinExport2_FieldNumber_DataReferenceArray = 15,
  BinExport2_FieldNumber_ModuleArray = 16,
  BinExport2_FieldNumber_CommentArray = 17,
};

GPB_FINAL @interface BinExport2 : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) BinExport2_Meta *metaInformation;
/** Test to see if @c metaInformation has been set. */
@property(nonatomic, readwrite) BOOL hasMetaInformation;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Expression*> *expressionArray;
/** The number of items in @c expressionArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger expressionArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Operand*> *operandArray;
/** The number of items in @c operandArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger operandArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Mnemonic*> *mnemonicArray;
/** The number of items in @c mnemonicArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger mnemonicArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Instruction*> *instructionArray;
/** The number of items in @c instructionArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger instructionArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_BasicBlock*> *basicBlockArray;
/** The number of items in @c basicBlockArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger basicBlockArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_FlowGraph*> *flowGraphArray;
/** The number of items in @c flowGraphArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger flowGraphArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) BinExport2_CallGraph *callGraph;
/** Test to see if @c callGraph has been set. */
@property(nonatomic, readwrite) BOOL hasCallGraph;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *stringTableArray;
/** The number of items in @c stringTableArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger stringTableArray_Count;

/**
 * No longer written. This is here so that BinDiff can work with older
 * BinExport files.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Reference*> *addressCommentArray GPB_DEPRECATED_MSG("BinExport2.address_comment is deprecated (see binexport2.proto).");
/** The number of items in @c addressCommentArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger addressCommentArray_Count GPB_DEPRECATED_MSG("BinExport2.address_comment is deprecated (see binexport2.proto).");

/** Rich comment index used for BinDiff's comment porting. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Comment*> *commentArray;
/** The number of items in @c commentArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger commentArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Reference*> *stringReferenceArray;
/** The number of items in @c stringReferenceArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger stringReferenceArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Reference*> *expressionSubstitutionArray;
/** The number of items in @c expressionSubstitutionArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger expressionSubstitutionArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Section*> *sectionArray;
/** The number of items in @c sectionArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger sectionArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Library*> *libraryArray;
/** The number of items in @c libraryArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger libraryArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_DataReference*> *dataReferenceArray;
/** The number of items in @c dataReferenceArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger dataReferenceArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_Module*> *moduleArray;
/** The number of items in @c moduleArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger moduleArray_Count;

@end

#pragma mark - BinExport2_Meta

typedef GPB_ENUM(BinExport2_Meta_FieldNumber) {
  BinExport2_Meta_FieldNumber_ExecutableName = 1,
  BinExport2_Meta_FieldNumber_ExecutableId = 2,
  BinExport2_Meta_FieldNumber_ArchitectureName = 3,
  BinExport2_Meta_FieldNumber_Timestamp = 4,
};

GPB_FINAL @interface BinExport2_Meta : GPBMessage

/**
 * Input binary filename including file extension but excluding file path.
 * example: "insider_gcc.exe"
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *executableName;
/** Test to see if @c executableName has been set. */
@property(nonatomic, readwrite) BOOL hasExecutableName;

/**
 * Application defined executable id. Often the SHA256 hash of the input
 * binary.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *executableId;
/** Test to see if @c executableId has been set. */
@property(nonatomic, readwrite) BOOL hasExecutableId;

/** Input architecture name, e.g. x86-32. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *architectureName;
/** Test to see if @c architectureName has been set. */
@property(nonatomic, readwrite) BOOL hasArchitectureName;

/**
 * When did this file get created? Unix time. This may be used for some
 * primitive versioning in case the file format ever changes.
 **/
@property(nonatomic, readwrite) int64_t timestamp;

@property(nonatomic, readwrite) BOOL hasTimestamp;
@end

#pragma mark - BinExport2_CallGraph

typedef GPB_ENUM(BinExport2_CallGraph_FieldNumber) {
  BinExport2_CallGraph_FieldNumber_VertexArray = 1,
  BinExport2_CallGraph_FieldNumber_EdgeArray = 2,
};

GPB_FINAL @interface BinExport2_CallGraph : GPBMessage

/** vertices == functions in the call graph. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_CallGraph_Vertex*> *vertexArray;
/** The number of items in @c vertexArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger vertexArray_Count;

/** edges == calls in the call graph. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_CallGraph_Edge*> *edgeArray;
/** The number of items in @c edgeArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger edgeArray_Count;

@end

#pragma mark - BinExport2_CallGraph_Vertex

typedef GPB_ENUM(BinExport2_CallGraph_Vertex_FieldNumber) {
  BinExport2_CallGraph_Vertex_FieldNumber_Address = 1,
  BinExport2_CallGraph_Vertex_FieldNumber_Type = 2,
  BinExport2_CallGraph_Vertex_FieldNumber_MangledName = 3,
  BinExport2_CallGraph_Vertex_FieldNumber_DemangledName = 4,
  BinExport2_CallGraph_Vertex_FieldNumber_LibraryIndex = 5,
  BinExport2_CallGraph_Vertex_FieldNumber_ModuleIndex = 6,
};

GPB_FINAL @interface BinExport2_CallGraph_Vertex : GPBMessage

/** The function's entry point address. */
@property(nonatomic, readwrite) uint64_t address;

@property(nonatomic, readwrite) BOOL hasAddress;
@property(nonatomic, readwrite) BinExport2_CallGraph_Vertex_Type type;

@property(nonatomic, readwrite) BOOL hasType;
/**
 * If the function has a user defined, real name it will be given here.
 * main() is a proper name, sub_BAADF00D is not (auto generated dummy
 * name).
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *mangledName;
/** Test to see if @c mangledName has been set. */
@property(nonatomic, readwrite) BOOL hasMangledName;

/**
 * Demangled name if the function is a mangled C++ function and we could
 * demangle it.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *demangledName;
/** Test to see if @c demangledName has been set. */
@property(nonatomic, readwrite) BOOL hasDemangledName;

/** If this is a library function, what is its index in library arrays. */
@property(nonatomic, readwrite) int32_t libraryIndex;

@property(nonatomic, readwrite) BOOL hasLibraryIndex;
/**
 * If module name, such as class name for DEX files, is present - index in
 * module table.
 **/
@property(nonatomic, readwrite) int32_t moduleIndex;

@property(nonatomic, readwrite) BOOL hasModuleIndex;
@end

#pragma mark - BinExport2_CallGraph_Edge

typedef GPB_ENUM(BinExport2_CallGraph_Edge_FieldNumber) {
  BinExport2_CallGraph_Edge_FieldNumber_SourceVertexIndex = 1,
  BinExport2_CallGraph_Edge_FieldNumber_TargetVertexIndex = 2,
};

GPB_FINAL @interface BinExport2_CallGraph_Edge : GPBMessage

/** source and target index into the vertex repeated field. */
@property(nonatomic, readwrite) int32_t sourceVertexIndex;

@property(nonatomic, readwrite) BOOL hasSourceVertexIndex;
@property(nonatomic, readwrite) int32_t targetVertexIndex;

@property(nonatomic, readwrite) BOOL hasTargetVertexIndex;
@end

#pragma mark - BinExport2_Expression

typedef GPB_ENUM(BinExport2_Expression_FieldNumber) {
  BinExport2_Expression_FieldNumber_Type = 1,
  BinExport2_Expression_FieldNumber_Symbol = 2,
  BinExport2_Expression_FieldNumber_Immediate = 3,
  BinExport2_Expression_FieldNumber_ParentIndex = 4,
  BinExport2_Expression_FieldNumber_IsRelocation = 5,
};

/**
 * An operand consists of 1 or more expressions, linked together as a tree.
 **/
GPB_FINAL @interface BinExport2_Expression : GPBMessage

/**
 * IMMEDIATE_INT is by far the most common type and thus we can save some
 * space by omitting it as the default.
 **/
@property(nonatomic, readwrite) BinExport2_Expression_Type type;

@property(nonatomic, readwrite) BOOL hasType;
/**
 * Symbol for this expression. Interpretation depends on type. Examples
 * include: "eax", "[", "+"
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *symbol;
/** Test to see if @c symbol has been set. */
@property(nonatomic, readwrite) BOOL hasSymbol;

/**
 * If the expression can be interpreted as an integer value (IMMEDIATE_INT)
 * the value is given here.
 **/
@property(nonatomic, readwrite) uint64_t immediate;

@property(nonatomic, readwrite) BOOL hasImmediate;
/**
 * The parent expression. Example expression tree for the second operand of:
 * mov eax, b4 [ebx + 12]
 * "b4" --- "[" --- "+" --- "ebx"
 *                       \\  "12"
 **/
@property(nonatomic, readwrite) int32_t parentIndex;

@property(nonatomic, readwrite) BOOL hasParentIndex;
/** true if the expression has entry in relocation table */
@property(nonatomic, readwrite) BOOL isRelocation;

@property(nonatomic, readwrite) BOOL hasIsRelocation;
@end

#pragma mark - BinExport2_Operand

typedef GPB_ENUM(BinExport2_Operand_FieldNumber) {
  BinExport2_Operand_FieldNumber_ExpressionIndexArray = 1,
};

/**
 * An instruction may have 0 or more operands.
 **/
GPB_FINAL @interface BinExport2_Operand : GPBMessage

/**
 * Contains all expressions constituting this operand. All expressions
 * should be linked into a single tree, i.e. there should only be one
 * expression in this list with parent_index == NULL and all others should
 * descend from that. Rendering order for expressions on the same tree level
 * (siblings) is implicitly given by the order they are referenced in this
 * repeated field.
 * Implicit: expression sequence
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *expressionIndexArray;
/** The number of items in @c expressionIndexArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger expressionIndexArray_Count;

@end

#pragma mark - BinExport2_Mnemonic

typedef GPB_ENUM(BinExport2_Mnemonic_FieldNumber) {
  BinExport2_Mnemonic_FieldNumber_Name = 1,
};

/**
 * An instruction has exactly 1 mnemonic.
 **/
GPB_FINAL @interface BinExport2_Mnemonic : GPBMessage

/** Literal representation of the mnemonic, e.g.: "mov". */
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;
/** Test to see if @c name has been set. */
@property(nonatomic, readwrite) BOOL hasName;

@end

#pragma mark - BinExport2_Instruction

typedef GPB_ENUM(BinExport2_Instruction_FieldNumber) {
  BinExport2_Instruction_FieldNumber_Address = 1,
  BinExport2_Instruction_FieldNumber_CallTargetArray = 2,
  BinExport2_Instruction_FieldNumber_MnemonicIndex = 3,
  BinExport2_Instruction_FieldNumber_OperandIndexArray = 4,
  BinExport2_Instruction_FieldNumber_RawBytes = 5,
  BinExport2_Instruction_FieldNumber_CommentIndexArray = 6,
};

GPB_FINAL @interface BinExport2_Instruction : GPBMessage

/**
 * This will only be filled for instructions that do not just flow from the
 * immediately preceding instruction. Regular instructions will have to
 * calculate their own address by adding raw_bytes.size() to the previous
 * instruction's address.
 **/
@property(nonatomic, readwrite) uint64_t address;

@property(nonatomic, readwrite) BOOL hasAddress;
/**
 * If this is a call instruction and call targets could be determined
 * they'll be given here. Note that we may or may not have a flow graph for
 * the target and thus cannot use an index into the flow graph table here.
 * We could potentially use call graph nodes, but linking instructions to
 * the call graph directly does not seem a good choice.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt64Array *callTargetArray;
/** The number of items in @c callTargetArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger callTargetArray_Count;

/**
 * Index into the mnemonic array of strings. Used for de-duping the data.
 * The default value is used for the most common mnemonic in the executable.
 **/
@property(nonatomic, readwrite) int32_t mnemonicIndex;

@property(nonatomic, readwrite) BOOL hasMnemonicIndex;
/**
 * Indices into the operand tree. On X86 this can be 0, 1 or 2 elements
 * long, 3 elements with VEX/EVEX.
 * Implicit: operand sequence
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *operandIndexArray;
/** The number of items in @c operandIndexArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger operandIndexArray_Count;

/** The unmodified input bytes corresponding to this instruction. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *rawBytes;
/** Test to see if @c rawBytes has been set. */
@property(nonatomic, readwrite) BOOL hasRawBytes;

/** Implicit: comment sequence */
@property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *commentIndexArray;
/** The number of items in @c commentIndexArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger commentIndexArray_Count;

@end

#pragma mark - BinExport2_BasicBlock

typedef GPB_ENUM(BinExport2_BasicBlock_FieldNumber) {
  BinExport2_BasicBlock_FieldNumber_InstructionIndexArray = 1,
};

GPB_FINAL @interface BinExport2_BasicBlock : GPBMessage

/** Implicit: instruction sequence */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_BasicBlock_IndexRange*> *instructionIndexArray;
/** The number of items in @c instructionIndexArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger instructionIndexArray_Count;

@end

#pragma mark - BinExport2_BasicBlock_IndexRange

typedef GPB_ENUM(BinExport2_BasicBlock_IndexRange_FieldNumber) {
  BinExport2_BasicBlock_IndexRange_FieldNumber_BeginIndex = 1,
  BinExport2_BasicBlock_IndexRange_FieldNumber_EndIndex = 2,
};

/**
 * This is a space optimization. The instructions for an individual basic
 * block will usually be in a continuous index range. Thus it is more
 * efficient to store the range instead of individual indices. However, this
 * does not hold true for all basic blocks, so we need to be able to store
 * multiple index ranges per block.
 **/
GPB_FINAL @interface BinExport2_BasicBlock_IndexRange : GPBMessage

/**
 * These work like begin and end iterators, i.e. the sequence is
 * [begin_index, end_index). If the sequence only contains a single
 * element end_index will be omitted.
 **/
@property(nonatomic, readwrite) int32_t beginIndex;

@property(nonatomic, readwrite) BOOL hasBeginIndex;
@property(nonatomic, readwrite) int32_t endIndex;

@property(nonatomic, readwrite) BOOL hasEndIndex;
@end

#pragma mark - BinExport2_FlowGraph

typedef GPB_ENUM(BinExport2_FlowGraph_FieldNumber) {
  BinExport2_FlowGraph_FieldNumber_BasicBlockIndexArray = 1,
  BinExport2_FlowGraph_FieldNumber_EdgeArray = 2,
  BinExport2_FlowGraph_FieldNumber_EntryBasicBlockIndex = 3,
};

GPB_FINAL @interface BinExport2_FlowGraph : GPBMessage

/** Basic blocks are sorted by address. */
@property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *basicBlockIndexArray;
/** The number of items in @c basicBlockIndexArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger basicBlockIndexArray_Count;

/**
 * The flow graph's entry point address is the first instruction of the
 * entry_basic_block.
 **/
@property(nonatomic, readwrite) int32_t entryBasicBlockIndex;

@property(nonatomic, readwrite) BOOL hasEntryBasicBlockIndex;
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BinExport2_FlowGraph_Edge*> *edgeArray;
/** The number of items in @c edgeArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger edgeArray_Count;

@end

#pragma mark - BinExport2_FlowGraph_Edge

typedef GPB_ENUM(BinExport2_FlowGraph_Edge_FieldNumber) {
  BinExport2_FlowGraph_Edge_FieldNumber_SourceBasicBlockIndex = 1,
  BinExport2_FlowGraph_Edge_FieldNumber_TargetBasicBlockIndex = 2,
  BinExport2_FlowGraph_Edge_FieldNumber_Type = 3,
  BinExport2_FlowGraph_Edge_FieldNumber_IsBackEdge = 4,
};

GPB_FINAL @interface BinExport2_FlowGraph_Edge : GPBMessage

/**
 * Source instruction will always be the last instruction of the source
 * basic block, target instruction the first instruction of the target
 * basic block.
 **/
@property(nonatomic, readwrite) int32_t sourceBasicBlockIndex;

@property(nonatomic, readwrite) BOOL hasSourceBasicBlockIndex;
@property(nonatomic, readwrite) int32_t targetBasicBlockIndex;

@property(nonatomic, readwrite) BOOL hasTargetBasicBlockIndex;
@property(nonatomic, readwrite) BinExport2_FlowGraph_Edge_Type type;

@property(nonatomic, readwrite) BOOL hasType;
/** Indicates whether this is a loop edge as determined by Lengauer-Tarjan. */
@property(nonatomic, readwrite) BOOL isBackEdge;

@property(nonatomic, readwrite) BOOL hasIsBackEdge;
@end

#pragma mark - BinExport2_Reference

typedef GPB_ENUM(BinExport2_Reference_FieldNumber) {
  BinExport2_Reference_FieldNumber_InstructionIndex = 1,
  BinExport2_Reference_FieldNumber_InstructionOperandIndex = 2,
  BinExport2_Reference_FieldNumber_OperandExpressionIndex = 3,
  BinExport2_Reference_FieldNumber_StringTableIndex = 4,
};

/**
 * Generic reference class used for address comments (deprecated), string
 * references and expression substitutions. It allows referencing from an
 * instruction, operand, expression subtree tuple to a de-duped string in the
 * string table.
 **/
GPB_FINAL @interface BinExport2_Reference : GPBMessage

/** Index into the global instruction table. */
@property(nonatomic, readwrite) int32_t instructionIndex;

@property(nonatomic, readwrite) BOOL hasInstructionIndex;
/** Index into the operand array local to an instruction. */
@property(nonatomic, readwrite) int32_t instructionOperandIndex;

@property(nonatomic, readwrite) BOOL hasInstructionOperandIndex;
/** Index into the expression array local to an operand. */
@property(nonatomic, readwrite) int32_t operandExpressionIndex;

@property(nonatomic, readwrite) BOOL hasOperandExpressionIndex;
/** Index into the global string table. */
@property(nonatomic, readwrite) int32_t stringTableIndex;

@property(nonatomic, readwrite) BOOL hasStringTableIndex;
@end

#pragma mark - BinExport2_DataReference

typedef GPB_ENUM(BinExport2_DataReference_FieldNumber) {
  BinExport2_DataReference_FieldNumber_InstructionIndex = 1,
  BinExport2_DataReference_FieldNumber_Address = 2,
};

GPB_FINAL @interface BinExport2_DataReference : GPBMessage

/** Index into the global instruction table. */
@property(nonatomic, readwrite) int32_t instructionIndex;

@property(nonatomic, readwrite) BOOL hasInstructionIndex;
/** Address being referred. */
@property(nonatomic, readwrite) uint64_t address;

@property(nonatomic, readwrite) BOOL hasAddress;
@end

#pragma mark - BinExport2_Comment

typedef GPB_ENUM(BinExport2_Comment_FieldNumber) {
  BinExport2_Comment_FieldNumber_InstructionIndex = 1,
  BinExport2_Comment_FieldNumber_InstructionOperandIndex = 2,
  BinExport2_Comment_FieldNumber_OperandExpressionIndex = 3,
  BinExport2_Comment_FieldNumber_StringTableIndex = 4,
  BinExport2_Comment_FieldNumber_Repeatable = 5,
  BinExport2_Comment_FieldNumber_Type = 6,
};

GPB_FINAL @interface BinExport2_Comment : GPBMessage

/**
 * Index into the global instruction table. This is here to enable
 * comment processing without having to iterate over all instructions.
 * There is an N:M mapping of instructions to comments.
 **/
@property(nonatomic, readwrite) int32_t instructionIndex;

@property(nonatomic, readwrite) BOOL hasInstructionIndex;
/** Index into the operand array local to an instruction. */
@property(nonatomic, readwrite) int32_t instructionOperandIndex;

@property(nonatomic, readwrite) BOOL hasInstructionOperandIndex;
/**
 * Index into the expression array local to an operand, like in Reference.
 * This is not currently used, but allows to implement expression
 * substitutions.
 **/
@property(nonatomic, readwrite) int32_t operandExpressionIndex;

@property(nonatomic, readwrite) BOOL hasOperandExpressionIndex;
/** Index into the global string table. */
@property(nonatomic, readwrite) int32_t stringTableIndex;

@property(nonatomic, readwrite) BOOL hasStringTableIndex;
/**
 * Comment is propagated to all locations that reference the original
 * location.
 **/
@property(nonatomic, readwrite) BOOL repeatable;

@property(nonatomic, readwrite) BOOL hasRepeatable;
@property(nonatomic, readwrite) BinExport2_Comment_Type type;

@property(nonatomic, readwrite) BOOL hasType;
@end

#pragma mark - BinExport2_Section

typedef GPB_ENUM(BinExport2_Section_FieldNumber) {
  BinExport2_Section_FieldNumber_Address = 1,
  BinExport2_Section_FieldNumber_Size = 2,
  BinExport2_Section_FieldNumber_FlagR = 3,
  BinExport2_Section_FieldNumber_FlagW = 4,
  BinExport2_Section_FieldNumber_FlagX = 5,
};

GPB_FINAL @interface BinExport2_Section : GPBMessage

/** Section start address. */
@property(nonatomic, readwrite) uint64_t address;

@property(nonatomic, readwrite) BOOL hasAddress;
/** Section size. */
@property(nonatomic, readwrite) uint64_t size;

@property(nonatomic, readwrite) BOOL hasSize;
/** Read flag of the section, True when section is readable. */
@property(nonatomic, readwrite) BOOL flagR;

@property(nonatomic, readwrite) BOOL hasFlagR;
/** Write flag of the section, True when section is writable. */
@property(nonatomic, readwrite) BOOL flagW;

@property(nonatomic, readwrite) BOOL hasFlagW;
/** Execute flag of the section, True when section is executable. */
@property(nonatomic, readwrite) BOOL flagX;

@property(nonatomic, readwrite) BOOL hasFlagX;
@end

#pragma mark - BinExport2_Library

typedef GPB_ENUM(BinExport2_Library_FieldNumber) {
  BinExport2_Library_FieldNumber_IsStatic = 1,
  BinExport2_Library_FieldNumber_LoadAddress = 2,
  BinExport2_Library_FieldNumber_Name = 3,
};

GPB_FINAL @interface BinExport2_Library : GPBMessage

/** If this library is statically linked. */
@property(nonatomic, readwrite) BOOL isStatic;

@property(nonatomic, readwrite) BOOL hasIsStatic;
/** Address where this library was loaded, 0 if unknown. */
@property(nonatomic, readwrite) uint64_t loadAddress;

@property(nonatomic, readwrite) BOOL hasLoadAddress;
/** Name of the library (format is platform-dependent). */
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;
/** Test to see if @c name has been set. */
@property(nonatomic, readwrite) BOOL hasName;

@end

#pragma mark - BinExport2_Module

typedef GPB_ENUM(BinExport2_Module_FieldNumber) {
  BinExport2_Module_FieldNumber_Name = 1,
};

GPB_FINAL @interface BinExport2_Module : GPBMessage

/** Name, such as Java class name. Platform-dependent. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;
/** Test to see if @c name has been set. */
@property(nonatomic, readwrite) BOOL hasName;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
