// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: binexport2.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Binexport2.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(BinExport2);
GPBObjCClassDeclaration(BinExport2_BasicBlock);
GPBObjCClassDeclaration(BinExport2_BasicBlock_IndexRange);
GPBObjCClassDeclaration(BinExport2_CallGraph);
GPBObjCClassDeclaration(BinExport2_CallGraph_Edge);
GPBObjCClassDeclaration(BinExport2_CallGraph_Vertex);
GPBObjCClassDeclaration(BinExport2_Comment);
GPBObjCClassDeclaration(BinExport2_DataReference);
GPBObjCClassDeclaration(BinExport2_Expression);
GPBObjCClassDeclaration(BinExport2_FlowGraph);
GPBObjCClassDeclaration(BinExport2_FlowGraph_Edge);
GPBObjCClassDeclaration(BinExport2_Instruction);
GPBObjCClassDeclaration(BinExport2_Library);
GPBObjCClassDeclaration(BinExport2_Meta);
GPBObjCClassDeclaration(BinExport2_Mnemonic);
GPBObjCClassDeclaration(BinExport2_Module);
GPBObjCClassDeclaration(BinExport2_Operand);
GPBObjCClassDeclaration(BinExport2_Reference);
GPBObjCClassDeclaration(BinExport2_Section);

#pragma mark - Binexport2Root

@implementation Binexport2Root

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - Binexport2Root_FileDescriptor

static GPBFileDescriptor *Binexport2Root_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - BinExport2

@implementation BinExport2

@dynamic hasMetaInformation, metaInformation;
@dynamic expressionArray, expressionArray_Count;
@dynamic operandArray, operandArray_Count;
@dynamic mnemonicArray, mnemonicArray_Count;
@dynamic instructionArray, instructionArray_Count;
@dynamic basicBlockArray, basicBlockArray_Count;
@dynamic flowGraphArray, flowGraphArray_Count;
@dynamic hasCallGraph, callGraph;
@dynamic stringTableArray, stringTableArray_Count;
@dynamic addressCommentArray, addressCommentArray_Count;
@dynamic commentArray, commentArray_Count;
@dynamic stringReferenceArray, stringReferenceArray_Count;
@dynamic expressionSubstitutionArray, expressionSubstitutionArray_Count;
@dynamic sectionArray, sectionArray_Count;
@dynamic libraryArray, libraryArray_Count;
@dynamic dataReferenceArray, dataReferenceArray_Count;
@dynamic moduleArray, moduleArray_Count;

typedef struct BinExport2__storage_ {
  uint32_t _has_storage_[1];
  BinExport2_Meta *metaInformation;
  NSMutableArray *expressionArray;
  NSMutableArray *operandArray;
  NSMutableArray *mnemonicArray;
  NSMutableArray *instructionArray;
  NSMutableArray *basicBlockArray;
  NSMutableArray *flowGraphArray;
  BinExport2_CallGraph *callGraph;
  NSMutableArray *stringTableArray;
  NSMutableArray *addressCommentArray;
  NSMutableArray *stringReferenceArray;
  NSMutableArray *expressionSubstitutionArray;
  NSMutableArray *sectionArray;
  NSMutableArray *libraryArray;
  NSMutableArray *dataReferenceArray;
  NSMutableArray *moduleArray;
  NSMutableArray *commentArray;
} BinExport2__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "metaInformation",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Meta),
        .number = BinExport2_FieldNumber_MetaInformation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2__storage_, metaInformation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expressionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Expression),
        .number = BinExport2_FieldNumber_ExpressionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, expressionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "operandArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Operand),
        .number = BinExport2_FieldNumber_OperandArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, operandArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mnemonicArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Mnemonic),
        .number = BinExport2_FieldNumber_MnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, mnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "instructionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Instruction),
        .number = BinExport2_FieldNumber_InstructionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, instructionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "basicBlockArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_BasicBlock),
        .number = BinExport2_FieldNumber_BasicBlockArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, basicBlockArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "flowGraphArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_FlowGraph),
        .number = BinExport2_FieldNumber_FlowGraphArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, flowGraphArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callGraph",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_CallGraph),
        .number = BinExport2_FieldNumber_CallGraph,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2__storage_, callGraph),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stringTableArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_FieldNumber_StringTableArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, stringTableArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addressCommentArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Reference),
        .number = BinExport2_FieldNumber_AddressCommentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, addressCommentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stringReferenceArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Reference),
        .number = BinExport2_FieldNumber_StringReferenceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, stringReferenceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expressionSubstitutionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Reference),
        .number = BinExport2_FieldNumber_ExpressionSubstitutionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, expressionSubstitutionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sectionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Section),
        .number = BinExport2_FieldNumber_SectionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, sectionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "libraryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Library),
        .number = BinExport2_FieldNumber_LibraryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, libraryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataReferenceArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_DataReference),
        .number = BinExport2_FieldNumber_DataReferenceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, dataReferenceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "moduleArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Module),
        .number = BinExport2_FieldNumber_ModuleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, moduleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_Comment),
        .number = BinExport2_FieldNumber_CommentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2__storage_, commentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2 class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const GPBExtensionRange ranges[] = {
      { .start = 100000000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_Meta

@implementation BinExport2_Meta

@dynamic hasExecutableName, executableName;
@dynamic hasExecutableId, executableId;
@dynamic hasArchitectureName, architectureName;
@dynamic hasTimestamp, timestamp;

typedef struct BinExport2_Meta__storage_ {
  uint32_t _has_storage_[1];
  NSString *executableName;
  NSString *executableId;
  NSString *architectureName;
  int64_t timestamp;
} BinExport2_Meta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "executableName",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Meta_FieldNumber_ExecutableName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_Meta__storage_, executableName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "executableId",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Meta_FieldNumber_ExecutableId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_Meta__storage_, executableId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "architectureName",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Meta_FieldNumber_ArchitectureName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BinExport2_Meta__storage_, architectureName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Meta_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BinExport2_Meta__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Meta class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Meta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_CallGraph

@implementation BinExport2_CallGraph

@dynamic vertexArray, vertexArray_Count;
@dynamic edgeArray, edgeArray_Count;

typedef struct BinExport2_CallGraph__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *vertexArray;
  NSMutableArray *edgeArray;
} BinExport2_CallGraph__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vertexArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_CallGraph_Vertex),
        .number = BinExport2_CallGraph_FieldNumber_VertexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph__storage_, vertexArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "edgeArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_CallGraph_Edge),
        .number = BinExport2_CallGraph_FieldNumber_EdgeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph__storage_, edgeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_CallGraph class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_CallGraph__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_CallGraph_Vertex

@implementation BinExport2_CallGraph_Vertex

@dynamic hasAddress, address;
@dynamic hasType, type;
@dynamic hasMangledName, mangledName;
@dynamic hasDemangledName, demangledName;
@dynamic hasLibraryIndex, libraryIndex;
@dynamic hasModuleIndex, moduleIndex;

typedef struct BinExport2_CallGraph_Vertex__storage_ {
  uint32_t _has_storage_[1];
  BinExport2_CallGraph_Vertex_Type type;
  int32_t libraryIndex;
  int32_t moduleIndex;
  NSString *mangledName;
  NSString *demangledName;
  uint64_t address;
} BinExport2_CallGraph_Vertex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_CallGraph_Vertex_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Vertex__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BinExport2_CallGraph_Vertex_Type_EnumDescriptor,
        .number = BinExport2_CallGraph_Vertex_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Vertex__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mangledName",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_CallGraph_Vertex_FieldNumber_MangledName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Vertex__storage_, mangledName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "demangledName",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_CallGraph_Vertex_FieldNumber_DemangledName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Vertex__storage_, demangledName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "libraryIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_CallGraph_Vertex_FieldNumber_LibraryIndex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Vertex__storage_, libraryIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "moduleIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_CallGraph_Vertex_FieldNumber_ModuleIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Vertex__storage_, moduleIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_CallGraph_Vertex class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_CallGraph_Vertex__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2_CallGraph)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum BinExport2_CallGraph_Vertex_Type

GPBEnumDescriptor *BinExport2_CallGraph_Vertex_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Normal\000Library\000Imported\000Thunk\000Invalid\000";
    static const int32_t values[] = {
        BinExport2_CallGraph_Vertex_Type_Normal,
        BinExport2_CallGraph_Vertex_Type_Library,
        BinExport2_CallGraph_Vertex_Type_Imported,
        BinExport2_CallGraph_Vertex_Type_Thunk,
        BinExport2_CallGraph_Vertex_Type_Invalid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BinExport2_CallGraph_Vertex_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BinExport2_CallGraph_Vertex_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BinExport2_CallGraph_Vertex_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BinExport2_CallGraph_Vertex_Type_Normal:
    case BinExport2_CallGraph_Vertex_Type_Library:
    case BinExport2_CallGraph_Vertex_Type_Imported:
    case BinExport2_CallGraph_Vertex_Type_Thunk:
    case BinExport2_CallGraph_Vertex_Type_Invalid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BinExport2_CallGraph_Edge

@implementation BinExport2_CallGraph_Edge

@dynamic hasSourceVertexIndex, sourceVertexIndex;
@dynamic hasTargetVertexIndex, targetVertexIndex;

typedef struct BinExport2_CallGraph_Edge__storage_ {
  uint32_t _has_storage_[1];
  int32_t sourceVertexIndex;
  int32_t targetVertexIndex;
} BinExport2_CallGraph_Edge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceVertexIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_CallGraph_Edge_FieldNumber_SourceVertexIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Edge__storage_, sourceVertexIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetVertexIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_CallGraph_Edge_FieldNumber_TargetVertexIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_CallGraph_Edge__storage_, targetVertexIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_CallGraph_Edge class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_CallGraph_Edge__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2_CallGraph)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_Expression

@implementation BinExport2_Expression

@dynamic hasType, type;
@dynamic hasSymbol, symbol;
@dynamic hasImmediate, immediate;
@dynamic hasParentIndex, parentIndex;
@dynamic hasIsRelocation, isRelocation;

typedef struct BinExport2_Expression__storage_ {
  uint32_t _has_storage_[1];
  BinExport2_Expression_Type type;
  int32_t parentIndex;
  NSString *symbol;
  uint64_t immediate;
} BinExport2_Expression__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = BinExport2_Expression_Type_ImmediateInt,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = BinExport2_Expression_Type_EnumDescriptor,
        .core.number = BinExport2_Expression_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(BinExport2_Expression__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "symbol",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BinExport2_Expression_FieldNumber_Symbol,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(BinExport2_Expression__storage_, symbol),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "immediate",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BinExport2_Expression_FieldNumber_Immediate,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(BinExport2_Expression__storage_, immediate),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "parentIndex",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BinExport2_Expression_FieldNumber_ParentIndex,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(BinExport2_Expression__storage_, parentIndex),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isRelocation",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BinExport2_Expression_FieldNumber_IsRelocation,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Expression class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(BinExport2_Expression__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum BinExport2_Expression_Type

GPBEnumDescriptor *BinExport2_Expression_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Symbol\000ImmediateInt\000ImmediateFloat\000Opera"
        "tor\000Register\000SizePrefix\000Dereference\000";
    static const int32_t values[] = {
        BinExport2_Expression_Type_Symbol,
        BinExport2_Expression_Type_ImmediateInt,
        BinExport2_Expression_Type_ImmediateFloat,
        BinExport2_Expression_Type_Operator,
        BinExport2_Expression_Type_Register,
        BinExport2_Expression_Type_SizePrefix,
        BinExport2_Expression_Type_Dereference,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BinExport2_Expression_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BinExport2_Expression_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BinExport2_Expression_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BinExport2_Expression_Type_Symbol:
    case BinExport2_Expression_Type_ImmediateInt:
    case BinExport2_Expression_Type_ImmediateFloat:
    case BinExport2_Expression_Type_Operator:
    case BinExport2_Expression_Type_Register:
    case BinExport2_Expression_Type_SizePrefix:
    case BinExport2_Expression_Type_Dereference:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BinExport2_Operand

@implementation BinExport2_Operand

@dynamic expressionIndexArray, expressionIndexArray_Count;

typedef struct BinExport2_Operand__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *expressionIndexArray;
} BinExport2_Operand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "expressionIndexArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Operand_FieldNumber_ExpressionIndexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_Operand__storage_, expressionIndexArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Operand class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Operand__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_Mnemonic

@implementation BinExport2_Mnemonic

@dynamic hasName, name;

typedef struct BinExport2_Mnemonic__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} BinExport2_Mnemonic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Mnemonic_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_Mnemonic__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Mnemonic class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Mnemonic__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_Instruction

@implementation BinExport2_Instruction

@dynamic hasAddress, address;
@dynamic callTargetArray, callTargetArray_Count;
@dynamic hasMnemonicIndex, mnemonicIndex;
@dynamic operandIndexArray, operandIndexArray_Count;
@dynamic hasRawBytes, rawBytes;
@dynamic commentIndexArray, commentIndexArray_Count;

typedef struct BinExport2_Instruction__storage_ {
  uint32_t _has_storage_[1];
  int32_t mnemonicIndex;
  GPBUInt64Array *callTargetArray;
  GPBInt32Array *operandIndexArray;
  NSData *rawBytes;
  GPBInt32Array *commentIndexArray;
  uint64_t address;
} BinExport2_Instruction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Instruction_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_Instruction__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "callTargetArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Instruction_FieldNumber_CallTargetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_Instruction__storage_, callTargetArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "mnemonicIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Instruction_FieldNumber_MnemonicIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_Instruction__storage_, mnemonicIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "operandIndexArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Instruction_FieldNumber_OperandIndexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_Instruction__storage_, operandIndexArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rawBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Instruction_FieldNumber_RawBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BinExport2_Instruction__storage_, rawBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "commentIndexArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Instruction_FieldNumber_CommentIndexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_Instruction__storage_, commentIndexArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Instruction class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Instruction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_BasicBlock

@implementation BinExport2_BasicBlock

@dynamic instructionIndexArray, instructionIndexArray_Count;

typedef struct BinExport2_BasicBlock__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *instructionIndexArray;
} BinExport2_BasicBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "instructionIndexArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_BasicBlock_IndexRange),
        .number = BinExport2_BasicBlock_FieldNumber_InstructionIndexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_BasicBlock__storage_, instructionIndexArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_BasicBlock class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_BasicBlock__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_BasicBlock_IndexRange

@implementation BinExport2_BasicBlock_IndexRange

@dynamic hasBeginIndex, beginIndex;
@dynamic hasEndIndex, endIndex;

typedef struct BinExport2_BasicBlock_IndexRange__storage_ {
  uint32_t _has_storage_[1];
  int32_t beginIndex;
  int32_t endIndex;
} BinExport2_BasicBlock_IndexRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "beginIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_BasicBlock_IndexRange_FieldNumber_BeginIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_BasicBlock_IndexRange__storage_, beginIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_BasicBlock_IndexRange_FieldNumber_EndIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_BasicBlock_IndexRange__storage_, endIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_BasicBlock_IndexRange class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_BasicBlock_IndexRange__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2_BasicBlock)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_FlowGraph

@implementation BinExport2_FlowGraph

@dynamic basicBlockIndexArray, basicBlockIndexArray_Count;
@dynamic hasEntryBasicBlockIndex, entryBasicBlockIndex;
@dynamic edgeArray, edgeArray_Count;

typedef struct BinExport2_FlowGraph__storage_ {
  uint32_t _has_storage_[1];
  int32_t entryBasicBlockIndex;
  GPBInt32Array *basicBlockIndexArray;
  NSMutableArray *edgeArray;
} BinExport2_FlowGraph__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "basicBlockIndexArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_FlowGraph_FieldNumber_BasicBlockIndexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_FlowGraph__storage_, basicBlockIndexArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "edgeArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BinExport2_FlowGraph_Edge),
        .number = BinExport2_FlowGraph_FieldNumber_EdgeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BinExport2_FlowGraph__storage_, edgeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "entryBasicBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_FlowGraph_FieldNumber_EntryBasicBlockIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_FlowGraph__storage_, entryBasicBlockIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_FlowGraph class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_FlowGraph__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_FlowGraph_Edge

@implementation BinExport2_FlowGraph_Edge

@dynamic hasSourceBasicBlockIndex, sourceBasicBlockIndex;
@dynamic hasTargetBasicBlockIndex, targetBasicBlockIndex;
@dynamic hasType, type;
@dynamic hasIsBackEdge, isBackEdge;

typedef struct BinExport2_FlowGraph_Edge__storage_ {
  uint32_t _has_storage_[1];
  int32_t sourceBasicBlockIndex;
  int32_t targetBasicBlockIndex;
  BinExport2_FlowGraph_Edge_Type type;
} BinExport2_FlowGraph_Edge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "sourceBasicBlockIndex",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BinExport2_FlowGraph_Edge_FieldNumber_SourceBasicBlockIndex,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(BinExport2_FlowGraph_Edge__storage_, sourceBasicBlockIndex),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "targetBasicBlockIndex",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BinExport2_FlowGraph_Edge_FieldNumber_TargetBasicBlockIndex,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(BinExport2_FlowGraph_Edge__storage_, targetBasicBlockIndex),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueEnum = BinExport2_FlowGraph_Edge_Type_Unconditional,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = BinExport2_FlowGraph_Edge_Type_EnumDescriptor,
        .core.number = BinExport2_FlowGraph_Edge_FieldNumber_Type,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(BinExport2_FlowGraph_Edge__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isBackEdge",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BinExport2_FlowGraph_Edge_FieldNumber_IsBackEdge,
        .core.hasIndex = 3,
        .core.offset = 4,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_FlowGraph_Edge class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(BinExport2_FlowGraph_Edge__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2_FlowGraph)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum BinExport2_FlowGraph_Edge_Type

GPBEnumDescriptor *BinExport2_FlowGraph_Edge_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ConditionTrue\000ConditionFalse\000Uncondition"
        "al\000Switch\000";
    static const int32_t values[] = {
        BinExport2_FlowGraph_Edge_Type_ConditionTrue,
        BinExport2_FlowGraph_Edge_Type_ConditionFalse,
        BinExport2_FlowGraph_Edge_Type_Unconditional,
        BinExport2_FlowGraph_Edge_Type_Switch,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BinExport2_FlowGraph_Edge_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BinExport2_FlowGraph_Edge_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BinExport2_FlowGraph_Edge_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BinExport2_FlowGraph_Edge_Type_ConditionTrue:
    case BinExport2_FlowGraph_Edge_Type_ConditionFalse:
    case BinExport2_FlowGraph_Edge_Type_Unconditional:
    case BinExport2_FlowGraph_Edge_Type_Switch:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BinExport2_Reference

@implementation BinExport2_Reference

@dynamic hasInstructionIndex, instructionIndex;
@dynamic hasInstructionOperandIndex, instructionOperandIndex;
@dynamic hasOperandExpressionIndex, operandExpressionIndex;
@dynamic hasStringTableIndex, stringTableIndex;

typedef struct BinExport2_Reference__storage_ {
  uint32_t _has_storage_[1];
  int32_t instructionIndex;
  int32_t instructionOperandIndex;
  int32_t operandExpressionIndex;
  int32_t stringTableIndex;
} BinExport2_Reference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "instructionIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Reference_FieldNumber_InstructionIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_Reference__storage_, instructionIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "instructionOperandIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Reference_FieldNumber_InstructionOperandIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_Reference__storage_, instructionOperandIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "operandExpressionIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Reference_FieldNumber_OperandExpressionIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BinExport2_Reference__storage_, operandExpressionIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stringTableIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Reference_FieldNumber_StringTableIndex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BinExport2_Reference__storage_, stringTableIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Reference class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Reference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_DataReference

@implementation BinExport2_DataReference

@dynamic hasInstructionIndex, instructionIndex;
@dynamic hasAddress, address;

typedef struct BinExport2_DataReference__storage_ {
  uint32_t _has_storage_[1];
  int32_t instructionIndex;
  uint64_t address;
} BinExport2_DataReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "instructionIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_DataReference_FieldNumber_InstructionIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_DataReference__storage_, instructionIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_DataReference_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_DataReference__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_DataReference class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_DataReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_Comment

@implementation BinExport2_Comment

@dynamic hasInstructionIndex, instructionIndex;
@dynamic hasInstructionOperandIndex, instructionOperandIndex;
@dynamic hasOperandExpressionIndex, operandExpressionIndex;
@dynamic hasStringTableIndex, stringTableIndex;
@dynamic hasRepeatable, repeatable;
@dynamic hasType, type;

typedef struct BinExport2_Comment__storage_ {
  uint32_t _has_storage_[1];
  int32_t instructionIndex;
  int32_t instructionOperandIndex;
  int32_t operandExpressionIndex;
  int32_t stringTableIndex;
  BinExport2_Comment_Type type;
} BinExport2_Comment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "instructionIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Comment_FieldNumber_InstructionIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_Comment__storage_, instructionIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "instructionOperandIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Comment_FieldNumber_InstructionOperandIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_Comment__storage_, instructionOperandIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "operandExpressionIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Comment_FieldNumber_OperandExpressionIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BinExport2_Comment__storage_, operandExpressionIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stringTableIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Comment_FieldNumber_StringTableIndex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BinExport2_Comment__storage_, stringTableIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "repeatable",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Comment_FieldNumber_Repeatable,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BinExport2_Comment_Type_EnumDescriptor,
        .number = BinExport2_Comment_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BinExport2_Comment__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Comment class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Comment__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum BinExport2_Comment_Type

GPBEnumDescriptor *BinExport2_Comment_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Default\000Anterior\000Posterior\000Function\000Enum"
        "\000Location\000GlobalReference\000LocalReference"
        "\000";
    static const int32_t values[] = {
        BinExport2_Comment_Type_Default,
        BinExport2_Comment_Type_Anterior,
        BinExport2_Comment_Type_Posterior,
        BinExport2_Comment_Type_Function,
        BinExport2_Comment_Type_Enum,
        BinExport2_Comment_Type_Location,
        BinExport2_Comment_Type_GlobalReference,
        BinExport2_Comment_Type_LocalReference,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BinExport2_Comment_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BinExport2_Comment_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BinExport2_Comment_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BinExport2_Comment_Type_Default:
    case BinExport2_Comment_Type_Anterior:
    case BinExport2_Comment_Type_Posterior:
    case BinExport2_Comment_Type_Function:
    case BinExport2_Comment_Type_Enum:
    case BinExport2_Comment_Type_Location:
    case BinExport2_Comment_Type_GlobalReference:
    case BinExport2_Comment_Type_LocalReference:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BinExport2_Section

@implementation BinExport2_Section

@dynamic hasAddress, address;
@dynamic hasSize, size;
@dynamic hasFlagR, flagR;
@dynamic hasFlagW, flagW;
@dynamic hasFlagX, flagX;

typedef struct BinExport2_Section__storage_ {
  uint32_t _has_storage_[1];
  uint64_t address;
  uint64_t size;
} BinExport2_Section__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Section_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_Section__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Section_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinExport2_Section__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "flagR",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Section_FieldNumber_FlagR,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "flagW",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Section_FieldNumber_FlagW,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "flagX",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Section_FieldNumber_FlagX,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Section class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Section__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_Library

@implementation BinExport2_Library

@dynamic hasIsStatic, isStatic;
@dynamic hasLoadAddress, loadAddress;
@dynamic hasName, name;

typedef struct BinExport2_Library__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  uint64_t loadAddress;
} BinExport2_Library__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isStatic",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Library_FieldNumber_IsStatic,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "loadAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Library_FieldNumber_LoadAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BinExport2_Library__storage_, loadAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Library_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BinExport2_Library__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Library class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Library__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinExport2_Module

@implementation BinExport2_Module

@dynamic hasName, name;

typedef struct BinExport2_Module__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} BinExport2_Module__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = BinExport2_Module_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinExport2_Module__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinExport2_Module class]
                                     rootClass:[Binexport2Root class]
                                          file:Binexport2Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinExport2_Module__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BinExport2)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
